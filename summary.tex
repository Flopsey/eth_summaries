%!TEX option = --shell-escape

\documentclass[12pt]{article}

\usepackage[utf8]{inputenc} 
\usepackage{enumitem}
\usepackage[left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}
\usepackage{minted} % colors for code
\usepackage{bussproofs} % proof trees
\usepackage{soul} % highlight text
\usepackage[x11names, dvipsnames]{xcolor} % choose color
\usepackage{amsthm} % for proof environment
\usepackage{hyperref} % Correct Section numbering
% math symbols
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}

\setitemize{align=left, topsep = 5pt, parsep = 2pt}
\setenumerate{align=left}
\sethlcolor{SkyBlue1}
\renewcommand*{\thesection}{\arabic{section}}

% Math shortcuts
\def\li{\rightarrow}
\def\fax{\forall x.}
\def\fay{\forall y.}
\def\faz{\forall z.}
\def\fan{\forall n. : Nat}
\def\exx{\exists x.}
\def\exy{\exists y.}
\def\exz{\exists z.}
\def\A{\mathcal{A}}
\def\B{\mathcal{B}}
\def\tt{\texttt{tt}}
\def\ff{\texttt{ff}}
\def\nott{\texttt{not }}
\def\andt{\texttt{ and }}
\def\ort{\texttt{ or }}
\def\ift{\texttt{if }}
\def\thent{\texttt{ then }}
\def\elset{\texttt{ else }}
\def\endt{\texttt{ end}}
\def\skipt{\texttt{skip}}
\def\whilet{\texttt{while }}
\def\dot{\texttt{ do }}
\def\llb{\llbracket}
\def\rrb{\rrbracket}

\title{FMFP}
\author{Isabel Haas}
\date{June 2022}

\begin{document}
% \maketitle

\begin{abstract}
This document should give an overview over the types of exercises in the FMFP course and how to solve them. 
It also contains parts of theory and an overview of Haskell. \\
Main sources are the course material and material provided by the course TA
Max Schlegel on https://n.ethz.ch/~mschlegel/fmfp22/fmfp.html.
\end{abstract}

\thispagestyle{empty}
\tableofcontents

\newpage

\part*{Functional Programming}
\addcontentsline{toc}{part}{Functional Programming}
\setcounter{section}{0}
\renewcommand*{\theHsection}{chX.\the\value{section}}

\section{Haskell}
\setcounter{page}{1}
\subsection{Basics}
\begin{minted}{Haskell}
-- Basic function
-- Declaration, comparable to int add(int a, int b){} in Java
add :: Int -> Int -> Int 
add a b = a + b -- Definition
-- function composition
f (g x) = f.g x
-- $
f $ x = f x
f $ map g xs = f (map g xs) -- to avoid parentheses 
-- functions can also be arguments
filter :: (a->Bool) -> [a] -> [a] -- first arg: function taking a returning Bool
-- Pattern matching
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
-- Guards
myAbs :: Int -> Int 
myAbs x
    | x < 0 = -x
    | otherwise = x
-- where 
f :: Int -> Int
f x = 1 + magic 
    where magic = sqrt x
-- let <def> in <expr> equal to <expr> where <def>
f :: Int -> Int
f x = (let magic = sqrt x in 1 + magic)
-- case expression (pattern matching)
case expression of pattern1 -> result1
                   pattern2 -> result2
div1byx :: Double -> Double
div1byx = case x of 0 -> 0.0
                    n -> 1/n
-- if else
if b then x else y -- returns either x or y
f x = if (prime x) then "PRIME" else "NOT" 
\end{minted}

\subsection{Lists}
\begin{minted}{Haskell}
[] -- empty list
x:xs -- first element is x, xs is rest of list
[a,b,c] -- syntactic sugar for a:b:c:[]
-- Basic pattern matching
f [] = 0
f (x:xs) = 2 + f xs
-- [1..x]
[1..4] -- [1,2,3,4]
[1,3..10] -- [1,3,5,7,9]
[5, 4..1] -- [5,4,3,2,1] 
[5..1] -- []
[1,2...] -- [1,2,...], used with lazy evaluation
-- List comprehensions
[f x | x <- list , guard_1, ..., guard_n]
[2*x | x <- [1..20], x `mod` 2 == 1] -- [2,6,10,..38]
[(l,r)| l <- "abc", r <- "xyz"] -- all comb. of characters in "abc" & "xyz"
-- Quick sort, very pretty
q (p:xs) = q [x | x <- xs, x <= p] ++ [p] ++ q [x | x <- xs, x > p]
\end{minted}

\subsection{Prelude functions}
\begin{minted}{Haskell}
-- Basics
head [1,2,3] -- 1 :: Int
tail [1,2,3] -- [2,3] :: [Int]
last [1,2,3] -- 3 :: Int
init [1,2,3] -- [1,2] :: [Int]
length [1,2,3] -- 3 :: Int
take 3 [1,2,3,4,5] -- [1,2,3] :: [Int]
drop 3 [1,2,3,4,5] -- [4,5] :: [Int]
reverse [1,2,3] -- [3,2,1] :: [Int]
maximum [1,2,3] -- 1 :: Int
minimum [1,2,3] -- 3 :: Int
sum [1,2,3,4] -- 10 :: Int
product [1,2,3,4] -- 24 :: Int
4 `elem` [1,2,3] -- False
-- More interesting
zip :: [a] -> [b] -> [(a,b)]
zip [1, 2] ['a', 'b'] == [(1,'a'),(2,'b')]
filter :: (a->Bool) -> [a] -> [a]
filter odd [1, 2, 3] -- [1,3]
map :: (a -> b) -> [a] -> [b]
map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
zipWith :: (a->b->c) -> [a] -> [b] -> [c]
zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
-- right associative
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
foldr f z (a:b:c:[]) = f a (f b (f c (f z [])))
foldr (+) 0 [1..4] = 
-- left associative
foldl :: (a -> b -> b) -> b -> [a] -> b
foldr f z [] = z
foldl f z xs = foldl f z . toList
foldl f z (a:b:c:[]) = f (f a (f b)) c
-- returns longest prefix of elements satisfying p and corresponding remainder of list
span :: (a -> Bool) -> [a] -> ([a], [a]) -- span p xs
span (< 3) [1,2,3,4,1,2,3,4] -- ([1,2],[3,4,1,2,3,4])
curry :: ((a,b)->c) -> a -> b -> c
curry f a b = f (a,b)
uncurry :: (a->b->c) -> (a,b) -> c
uncurry f (x,y) == f a b
\end{minted}

\subsection{Algebraic data types}
Define new types
\begin{minted}{Haskell}
-- Structure: on the right side are value constructors
-- data type can have one of those different values
data keyword = constr1 | constr2 | ... | constrn
-- Option can be simple types
data Bool = False | True
-- New value constructors can be defined
-- Circle takes three floats as fields, rectangle 4
data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
-- ghci> :t Circle
Circle :: Float -> Float -> Float -> Shape  
-- functions for data types
surface :: Shape -> Float  
surface (Circle _ _ r) = pi * r ^ 2  
surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1) 
-- has argument of type a or b
data myType a b = myConstr a | myOtherConstructor b
-- definitions can  be recursive
data myList a = Empty | Cons a (MyList a)
-- tree
data Tree t = Leaf | Node t (Tree t) (Tree t)

-- deriving keyword
-- typeclasses like Eq, Ord, Enum, Bounded, Show, Read can function as "interfaces"
-- Example: == and /= and can now be used to compare values
data Vector = Vector Int Int Int deriving (Eq, Show)

-- instance keyword
data TrafficLight = Red | Yellow | Green  
instance Eq TrafficLight where  
    Red == Red = True  
    Green == Green = True  
    Yellow == Yellow = True  
    _ == _ = False  
instance Show TrafficLight where  
    show Red = "Red light"  
    show Yellow = "Yellow light"  
    show Green = "Green light" 

-- fold for data types
-- data type:
data DType = C1 ... | C2 ... | ... | CN ...
-- fold
foldDType :: foldC1 -> foldC2 -> ... -> foldCN -> DType -> b
-- example
data Prop a = Var a | Not (Prop a) | And (Prop a) (Prop a) | Or (Prop a) (Prop a)
foldProp :: (a->b) -> (b->b) -> (b->b->b) -> (b->b->b) -> (Prop a) -> b
foldProp fVar fNot fAnd fOr prop  = go prop
    where 
        go (Var v) = fVar v
        go (Not v) = fNot (go v)
        go (And v w) = fAnd (go v) (go w) 
        go (Or v w) = fOr (go v) (go w)
\end{minted}  


\section{Evaluation strategies}
Lazy evaluation strategy of application \texttt{t1 t2}
\begin{enumerate}
    \item Evaluate \texttt{t1}
    \item The argument \texttt{t2} is substituted in \texttt{t1} without being evaluated
    \item No evaluation inside lambda abstractions. In other words, in an abstraction 
    \texttt{$\backslash$... -> f t}, then \texttt{f t} is not evaluated
\end{enumerate}
Eager evaluation strategy of application \texttt{t1 t2}
\begin{enumerate}
    \item Evaluate \texttt{t1}
    \item \texttt{t2} is evaluated prior to substitution in \texttt{t1}
    \item Evaluation is carried out inside lambda abstractions
\end{enumerate}

\subsection{Lazy evaluation in Haskell}
Haskell: Lazy Evaluation
\begin{itemize}
    \item argument only evaluated when no other steps possible
    \item left term is evaluated first
    \item argument made to fit pattern
\end{itemize}
\subsubsection{Sheet 1, Ex. 1}
\begin{minted}{Haskell}
fibLouis :: Int -> Int
fibLouis 0 = 1
fibLouis 1 = 1
fibLouis n = fibLouis (n - 1) + fibLouis (n - 2)
fibEva :: Int -> Int
fibEva n = fst (aux n) where 
    aux 0 = (0, 1)B
    aux n = next (aux (n - 1))
    next (a, b) = (b, a + b)
\end{minted}
\textbf{Lazy Evaluation of fibLouis 4}
\begin{verbatim}
fibLouis 4 =
fibLouis (4-1) + fibLouis (4-2) =
-- most left term is evaluated first
fibLouis 3 + fibLouis (4-2) =
(fibLouis (3-1) + fibLouis (3-2)) + fibLouis (4-2) 
...
((fibLouis 1 + fibLouis (2-2)) + fibLouis (3-2)) + fibLouis (4-2) =
((1 + fibLouis (2-2)) + fibLouis (3-2)) + fibLouis (4-2) =
...
2 + fibLouis 2 =
2 + (fibLouis (2-1) + fibLouis (2-2))
... = 3
\end{verbatim}
\textbf{Lazy Evaluation of fibEva 4}
\begin{verbatim}
fibEva 4 =
fst (aux 4) =
fst (next (aux (4-1))) =
fst (next (aux 3)) =
fst (next (next (aux (3-1)))) =
fst (next (next (aux 2))) =
...
fst (next (next (next (next (0, 1))))) =
fst (next (next (next (1, 0+1)))) =
fst (next (next (0+1, 1+(0+1)))) =
fst (next (1+(0+1), (0+1)+(1+(0+1)))) 
...
-- pattern (0+1) is repeated
fst ((0+1)+(1+(0+1)), (1+(0+1))+((0+1)+(1+(0+1)))) =
(0+1)+(1+(0+1)) =
1 + (1 + 1) =
3
\end{verbatim}

\section{Natural Deduction}
\subsection{Parenthesizing formulas} 
\begin{itemize}
    \item $\land$ binds stronger than $\lor$ stronger than $\li$
    \item $\li$ associates to right; $\land$ and $\lor$ to the left
    \item Negation binds stronger than binary operators 
    \item Quantifiers extend to the right as far as possible: end of line or )
\end{itemize}
\begin{tabular}{l l}
    $p \lor q \land \lnot r \li p \lor q$ & $(p \lor (q \land (\lnot r))) \li (p \lor q)$ \\
    $p \li q \lor p \li r$ & $p \li ((q \lor p) \li r$) \\
    $p \land \fax q(x) \lor r$ & $p \land (\fax (q(x) \lor r))$ \\
    $\lnot \fax p(x) \land \fax q(x) \land r(x) \land s$ &  $\lnot( \fax (p(x) \land (\fax ((q(x) \land r(x)) \land s))))$
\end{tabular} 
\subsection{Natural Deduction without quantifiers}
If you cannot continue, try to add assumptions by using $\lor E$
\subsubsection{Example}
\textbf{Exercise}: $P = (\lnot A) \land (A \lor B) \li B$ is a tautology \\
First step: Parenthesizing $\Rightarrow$ $P \equiv ((\lnot A) \land (A \lor B)) \li B$ \\
Let $\Gamma \equiv (\lnot A) \land (A \lor B)$

\begin{prooftree}
    \def\ScoreOverhang{1pt}\def\ScoreOverhang{1pt}

    \AxiomC{}
    \RightLabel{$ax$}
    \UnaryInfC{$\Gamma, A \vdash (\lnot A) \land (A \lor B)$}
    \RightLabel{$\land ER$}
    \UnaryInfC{$\Gamma \vdash A \lor B$}
        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\Gamma, A \vdash A$}

        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\Gamma, A \vdash (\lnot A) \land (A \lor B)$}
        \RightLabel{$\land EL$}
        \UnaryInfC{$\Gamma, A \vdash \lnot A$}

        \RightLabel{$\lnot E$}
        \BinaryInfC{$\Gamma, A \vdash B$}
            \AxiomC{}
            \RightLabel{$ax$}
            \UnaryInfC{$\Gamma, B \vdash B$}
        \RightLabel{$\lor E$}
        \TrinaryInfC{$\Gamma \vdash B$}
        \RightLabel{$\li I$}
        \UnaryInfC{ $\vdash (\lnot A) \land (A \lor B)$}
\end{prooftree}

\subsection{Natural Deduction with quantifiers}
If you cannot continue, try to add assumptions by using $\exists E$ \\
Always check side conditions
\subsubsection{Sheet 2, Ex. 3b}
\textbf{Exercise}: Proof $(\exx P \land Q) \li ((\exx P) \lor (\exx Q)) $ \\
Let $\Gamma \equiv \exx P \land Q, P \land Q$
\begin{prooftree}
    \def\ScoreOverhang{1pt}\def\ScoreOverhang{1pt}

    \AxiomC{}
    \RightLabel{$ax$}
    \UnaryInfC{$(\exx P \land Q) \vdash (\exx P \land Q)$}
        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\Gamma \vdash P \land Q$}
        \RightLabel{$\land EL$}
        \UnaryInfC{$\Gamma \vdash P$}
        \RightLabel{$\exists I$}
        \UnaryInfC{$\Gamma \vdash \exx P$}

        \AxiomC{}
        \RightLabel{$ax$}
        \UnaryInfC{$\Gamma \vdash P \land Q$}
        \RightLabel{$\land ER$}
        \UnaryInfC{$\Gamma \vdash Q$}
        \RightLabel{$\exists I$}
        \UnaryInfC{$\Gamma \vdash \exx Q$}

        \RightLabel{$\land I$}
        \BinaryInfC{$\Gamma \vdash (\exx P) \lor (\exx Q)$}
    \RightLabel{$\exists E ^{**}$}
    \BinaryInfC{$(\exx P \land Q) \vdash (\exx P) \lor (\exx Q)$}
    \RightLabel{$\li I$}
    \UnaryInfC{$\vdash (\exx P \land Q) \li ((\exx P) \lor (\exx Q))$}
\end{prooftree}

** side condition OK: x not free in $\exx P \land Q$ nor $(\exx P) \lor (\exx Q)$

\section{Binding and $\alpha$-conversion}
\textbf{Bound}: Each occurrence of a variable is bound or free:
A variable occurrence x in a formula A is \textbf{bound} if x occurs within a sub formula B of A of the form $\exx B$ or $\fax B$.
\textbf{Alpha-conversion}: bound variables can be renamed \\
\textbf{Examples} \\
\begin{tabular}{l l c}
     & & $\alpha$-convertible \\
    $\fax \exy p(x,y)$ & $\fay \exx p(y,x)$ & yes \\
    $\exz \fay p(z, f(y))$ &  $\exy \fay p(y, f(y))$ & no \\
    $(\fax p(x)) \lor (\exx q(x))$ & $(\faz p(z)) \lor (\exy q(y))$ & yes \\
    $p(x) \li \fax p(x)$ & $p(y) \li \fay p(y)$ & no \\
\end{tabular}

\section{Induction}
For proofs with \texttt{[]}, \texttt{0}. \texttt{Leaf} or similar, you may first have to proof a generalised statement with 
induction and then simply plug in your values.
\subsection{Induction on natural numbers}
Induction scheme:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash P[n \mapsto 0]$}
    \AxiomC{$\Gamma, P[n \mapsto m] \vdash  P[n \mapsto m+1]$}
    \RightLabel{$m$ not free in P}
    \BinaryInfC{$\Gamma \vdash \forall n : Nat. P$}
\end{prooftree}

\subsubsection{Sheet 3, Ex. 1b}
(Important parts/"framework" of proof) \\
\textbf{Lemma}: $\fan$ \texttt{aux n = (fibLouis n, fibLouis (n+1))}
\begin{proof}
    Let \texttt{P:=}(aux n = (fibLouis n, fibLouis (n+1)))\\
    \textbf{Base case}. Show \texttt{P[n $\mapsto$ 0]} 
    \begin{minted}{Haskell}
    aux 0 = ...
        = (fibLouis 0, fibLouis (0+1))
    \end{minted}
    \textbf{Step case}. Let \texttt{m:Nat} be arbitrary. \\
    Show that \texttt{P[n $\mapsto$ m]} implies \texttt{P[n $\mapsto$ m+1]}. \\
    Assume \texttt{aux m = (fibLouis m, fibLouis (m+1))}
    \begin{minted}{Haskell}
    aux (m+1) = ...
            = (fibLouis (m+1), fibLouis ((m+1)+1)) 
    \end{minted}
\end{proof}

\subsection{Induction on lists}

Induction scheme:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash P[xs \mapsto []]$}
    \AxiomC{$\Gamma, P[xs \mapsto ys] \vdash P[xs \mapsto (y:ys)]$}
    \RightLabel{$y, ys$ not free in P}
    \BinaryInfC{$\Gamma \vdash \forall xs :: [a]. P$}
\end{prooftree}

\subsubsection{Sheet 3, Ex. 2b}
(Important parts/"framework" of proof) \\
\textbf{Lemma}: \texttt{foldr (:) [] xs = xs}
\begin{proof}
    Let \texttt{P:= (foldr (:) [] xs = xs)}. \\
    We prove by induction over lists that $\forall xs::[a].$ \texttt{P} holds. \\
    \textbf{Base case}. Show \texttt{P[xs $\mapsto$ []]} 
    \begin{minted}{Haskell}
    foldr (:) [] [] = [] 
    \end{minted}
    \textbf{Step case}. Let \texttt{y::a, ys::[a]} be arbitrary. \\
    Show that \texttt{P[xs $\mapsto$ ys]} implies \texttt{P[xs $\mapsto$ (y:ys)]} \\
    Assume \texttt{foldr (:) [] ys = ys} and we show that \texttt{foldr (:) [] (y:ys) = y:ys}
    \begin{minted}{Haskell}
    foldr (:) [] (y:ys) = 
        = ...
        = (y:ys)
    \end{minted}
\end{proof}
\subsubsection{Sheet 4, Ex. 1}
(Important parts/"framework" of proof) \\
\textbf{Lemma}: \texttt{rev (xs ++ rev ys) = ys ++ rev xs}
\begin{proof}
    Let \texttt{P' := rev (xs ++ rev ys') = ys' ++ rev xs}. 
    We show that $\forall$ \texttt{ys'.}$\forall$ \texttt{xs.}. \\
    Fix an arbitrary \texttt{ys} and let \texttt{P := [ys' $\mapsto$ ys]}.
    We show that $\forall$\texttt{xs P.} \\
    (This implies $\forall$\texttt{ys'.}$\forall$\texttt{xs.P'}) \\
    \textbf{Base case}: We show \texttt{P[xs $\mapsto$ []]} 
    \begin{minted}{Haskell}
    rev ([] ++ rev ys) = ...
        = ys ++ rev []
    \end{minted}
    \textbf{Step case}: We need to show 
    $\forall$\texttt{z, zs P[xs $\mapsto$ zs]} $\li$ \texttt{ P[xs $\mapsto$ (z:zs)]}.\\
    Fix arbitrary \texttt{y::a}, \texttt{ys::[a]}. \\
    We assume \texttt{IH: rev (zs ++ rev ys) = ys ++ rev zs} \\
    and show that \texttt{rev ((z:zs) ++ rev ys) = ys ++ rev (z:zs)}
    
    \begin{minted}{Haskell}
    rev ((z:zs) ++ rev ys)
        = ...
        = ys ++ rev (z:zs)
    \end{minted}
\end{proof}

\subsection{Induction on Trees}
\begin{minted}{Haskell}
data Tree t = Leaf | Node t (Tree t) (Tree t)
\end{minted}

Induction scheme:
\begin{prooftree}
    \AxiomC{$\Gamma \vdash P[x \mapsto \text{Leaf} ]$}
    \AxiomC{$\Gamma, P[x \mapsto l], P[x \mapsto r] \vdash P[x \mapsto \text{Node } a \, l \, r]$}
    \RightLabel{$a,l,r$ not free in P}
    \BinaryInfC{$\Gamma \vdash \forall xs :: \text{Tree } t. P$}
\end{prooftree}

\subsubsection{Sheet 6, Ex. 1}
(Important parts/"framework" of proof) 
\begin{minted}{Haskell}
mapTree f Leaf = Leaf
mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2) 
\end{minted}  
For arbitrary \mintinline{Haskell}{f :: a -> b} and \mintinline{Haskell}{g :: b -> c} \\
$\forall$\texttt{t :: Tree a. mapTree g (mapTree f t) = mapTree (g . f) t}

\begin{proof}
Let \mintinline{Haskell}{f :: a -> b} and \mintinline{Haskell}{g :: b -> c} be arbitrary functions. \\
Let \texttt{P := mapTree g (mapTree f t) = mapTree (g . f) t}, and we prove by induction that 
$\forall$\texttt{t :: (Tree a).P} \\
\textbf{Base Case}: Show \texttt{P[t $\mapsto$ Leaf]} 
\begin{minted}{Haskell}
    mapTree g (mapTree f Leaf) = ..
            =  mapTree (g . f) Leaf
\end{minted}
\textbf{Step case}: 
Let \texttt{x::a, l::Tree a, r::Tree a} be arbitrary. \\
Assume \texttt{P[t $\mapsto$ l]} and \texttt{P[t $\mapsto$ r]}. (IH) \\
We know show that then \texttt{P[t $\mapsto$ Node x l r]} holds 
\begin{minted}{Haskell}
    mapTree g (mapTree f (Node x l r)) = ..
            =  mapTree (g . f) (Node x l r)
\end{minted}
\end{proof}



\section{Types and typing inference}
\texttt{f :: a -> b -> c -> d}:
\begin{itemize}
    \item same as \texttt{f :: a -> (b -> (c -> d))} (parentheses are right associative) 
    \item \texttt{f x y z} implies \texttt{x::a, y::b, z::c} 
    \item f.e. \texttt{f x :: b -> c -> d}
\end{itemize}
\subsection{Types}
\begin{itemize}
    \item Detect function applications, f.e. \texttt{f x} $\Rightarrow$ \texttt{f::a->b, x::a}
    \item Detect prelude functions such as map, filter, foldr etc.
    \item "Match" types of different function, f.e. \texttt{f :: (a->b) -> [a] -> b} for  \texttt{f x} $\Rightarrow$ \texttt{x :: (a->b)}
    \item Don't forget things like \texttt{Num a, Eq b => ...}
\end{itemize}
% \textbf{Example} \\
% \mintinline{Haskell}{\x y -> (fst x) + y}
% \mintinline{Haskell}{(+) :: (Num a => a -> a -> a)} and \mintinline{Haskell}{fst :: (a,b) -> a} \\
% $\Rightarrow$ \mintinline{Haskell}{y :: (Num a) => a}, \mintinline{Haskell}{(fst x) ::  (Num a) => a} and
% \mintinline{Haskell}{x :: (c,b)} \\
% $\Rightarrow$ \mintinline{Haskell}{\x y -> (fst x) + y :: Num a => (a,b) -> a -> a}
\subsubsection{Sheet 5}
\textbf{1a} \verb|\x y z -> (x y) z|
\begin{enumerate}
    \item Three arguments, one return value
    \item \verb|(x y) :: a -> b| and \verb|z :: a|
    \item \verb|x :: c -> (a->b)| and \verb|y :: c|
    \item \verb|\x y z -> (x y) z :: (c -> a -> b) -> c -> a -> b|
\end{enumerate}
\textbf{2a.4} \texttt{(.).(.)} (the end boss)
\begin{enumerate}
    \item \texttt{(.) :: (b->c) -> (a->b) -> a -> c}
    \item Rewrite: \texttt{\textcolor{Red}{(.)}\textcolor{Cyan}{.}\textcolor{Green}{(.)} 
    = \textcolor{Cyan}{.}\textcolor{Red}{(.)}\textcolor{Green}{(.)} 
    = \textcolor{Cyan}{f} \textcolor{Red}{g} \textcolor{Green}{h}}
    \item Definition of \texttt{(.)}: \\
    \texttt{f :: (b->c) -> ((a->b) -> a -> c)} \\
    \texttt{g :: (n->o) -> ((m->n) -> m -> o)} \\
    \texttt{h :: (q->r) -> ((p->q) -> p -> r)} 
    \item \texttt{g} is first argument of \texttt{f}: \\
    \texttt{g :: b -> c} \\
    $\Rightarrow$ \texttt{b = n -> o} (I) and
    \texttt{c = (m->n) -> m -> o} (II)
    \item \texttt{h} is first argument of \texttt{f g}:\\
    \texttt{f g :: (a->b) -> a -> c}   \\
    $\Rightarrow$ \texttt{h :: a -> b}  \\
    $\Rightarrow$ \texttt{a = q -> r} (III)\\
    \texttt{(p->q) -> p -> r} (IV)
    \item (I) and (IV) $\Rightarrow$ 
    \texttt{n = p -> q} (V) and \texttt{o = p -> r}
    \item After"taking" two arguments, we have the following type \\
    \texttt{f g h :: a -> c} \\
    \texttt{= (q->r) -> (m->n) -> m -> o} \\
    \texttt{= (q->r) -> (m->p->q) -> m -> p -> r }
\end{enumerate}
\subsection{Typing proof and Inference}
Solving type inference constraints
\begin{enumerate}
    \item Remove trivial equations like $t = t$
    % \item Merge equations $\{x=s, x =t\}$ into $\{s=t\}$ (if x doesn't appear in other equations)
    \item Transform equations of form $\{f(s_0, ..., s_k)=g(t_0, ..., s_m)\}$ into $\{s_0 = t_0, ..., s_k = t_k\}$ if
    $f=g$ and $k=m$, else there is no solution
    \item Substitute one equation into the others 
\end{enumerate}
\subsubsection{Sheet 5, Ex. 3}
\textbf{a} Proof $\lambda$\texttt{x.(x 1 True, x 0) :: (Int -> Bool -> a) -> (a, Bool -> a)}:\\
Try to match left and right side with typing rule and apply it, should be straight forward \\
\textbf{b} Infer the type of ($\lambda$\texttt{x.}$\lambda$\texttt{y.(y (iszero (y x)))) True}
\begin{prooftree}
    \def\ScoreOverhang{1pt}\def\ScoreOverhang{1pt}
    \AxiomC{}
    \RightLabel{$Var^1$}
    \UnaryInfC{$x : \tau_1, y : \tau_2 \vdash y :: \tau_4 \li \tau_3$}
    \AxiomC{$\mathbf{T_2}$}
    \RightLabel{$App$}
    \BinaryInfC{$x : \tau_1, y : \tau_2\vdash y \; (\mathbf{iszero}\; (y \; x)) :: \tau_3$ }
    \RightLabel{$Abs^1$}
    \UnaryInfC{$ x : \tau_1 \vdash \lambda y. (y \; (\mathbf{iszero}\; (y \; x))) :: \tau_0$}
    \RightLabel{$Abs$}
    \UnaryInfC{$\vdash \lambda x. \lambda y. (y \; (\mathbf{iszero}\; (y \; x))) :: \tau_1 \li \tau_0$}
        \AxiomC{}
        \RightLabel{$True^1$}
        \UnaryInfC{$\vdash True :: \tau_1$}
    \RightLabel{$App$}
    
    \BinaryInfC{ $\vdash (\lambda x. \lambda y. (y \; (\mathbf{iszero} \; (y \; x)))) \; True :: \tau_0$ }
\end{prooftree}
T$_2$:
\begin{prooftree}
    \AxiomC{}
    \RightLabel{$Var^2$}
    \UnaryInfC{$x : \tau_1, y : \tau_2\vdash y :: \tau_5 \li Int$}
    \AxiomC{}
    \RightLabel{$Var^3$}
    \UnaryInfC{$x : \tau_1, y : \tau_2\vdash x :: \tau_5$}
    \RightLabel{$App$}
    \BinaryInfC{$x : \tau_1, y : \tau_2 \vdash  y \; x :: Int$}
    \RightLabel{$iszero^1$}
    \UnaryInfC{$x : \tau_1, y : \tau_2\vdash \mathbf{iszero}\; (y \; x) :: \tau_4$}
    
\end{prooftree}

Finding out $\tau_0$: \\ \\
\begin{tabular}{l | l | l | l }
    $\tau_0 = \tau_2 \li \tau_3$ ($Abs^1$) & $\tau_0 = \tau_2 \li \tau_3$ & $\tau_0 = \tau_2 \li \tau_3$
    &  $\tau_0 = (Bool \li Int) \li \tau_3$\\

    $\tau_2 = \tau_4 \li \tau_3$ ($Var^1$) & $\tau_2 = \tau_4 \li \tau_3$ & $\tau_2 = \tau_4 \li \tau_3$
    & $Bool \li Int=\tau_4 \li \tau_3$\\

    $\tau_4 = Bool$ ($iszero^1$)& $\tau_4 = Bool$ & $\tau_4 = Bool$
    & $\tau_4 = Bool$\\

    $\tau_2 = \tau_5 \li Int$ ($Var^2$)& $\tau_2 = \tau_5 \li Int$ & $\tau_2 = Bool \li Int$
    & $\tau_5 = Bool$\\

    $\tau_1 = \tau_5$ ($Var^3$)& $\tau_5 = Bool$ & $\tau_5 = Bool$
    & \\

    $\tau_1 = Bool$ ($True^1$)& & & \\ \hline
\end{tabular}
\\
\begin{tabular}{l | l}
    $\tau_0 = (Bool \li Int) \li \tau_3$ & $\tau_0 = (Bool \li Int) \li Int$\\
    $\tau_3 = Int$ &  $\tau_3 = Int$\\
    $\tau_4 = Bool$ & $\tau_4 = Bool$\\
    $\tau_5 = Bool$ &  $\tau_5 = Bool$\\
\end{tabular}
\\ \\
\textbf{d} Infer type of \texttt{iszero(fst (3+5))}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{$Int$}
    \UnaryInfC{$\vdash 3 :: Int$}
    \AxiomC{}
    \RightLabel{$Int$}
    \UnaryInfC{$\vdash 5 :: Int$}
    \RightLabel{$BinOp$}
    \BinaryInfC{$\vdash(3+5) :: (Int, \tau_1)$}
    \RightLabel{$fst$}
    \UnaryInfC{$\vdash \mathbf{fst} (3+5) :: Int$}
    \RightLabel{$iszero$}
    \UnaryInfC{$\vdash \mathbf{iszero}(\mathbf{fst} (3+5)) :: \tau_0$}
\end{prooftree}
Collected type constraints: $\tau_0 = Bool$ from $iszero$, $(Int = (Int, \tau_1))$ from $BinOp$, 
second constraint does not unify, meaning this doesn't type


\part*{Formal Methods}
\addcontentsline{toc}{part}{Formal Methods}
\setcounter{section}{0}
\renewcommand*{\theHsection}{chY.\the\value{section}}

\section{States and Expressions}
\subsection{States}
\textbf{State as a function}: 
$$\text{State: Var} \li \text{Val}$$ 
\textbf{Zero state}: 
$$\sigma_{zero}(x)=0\text{ for all }x$$
\textbf{Updating states}: 
$$ (\sigma[y\mapsto v](x)) = \begin{cases}
v & \text{if } x \equiv y \\
\sigma(x) & x \not\equiv y \\
\end{cases}
$$
\textbf{Two states are equal}:
$$ \sigma_1 = sigma_2 \Leftrightarrow \fax (\sigma_1(x) = \sigma_2(x))$$

\subsection{Semantics of arithmetic expression}
\textbf{Semantic function}:
$$ \A: \text{Aexp}\li \text{State} \li \text{Val}$$
\textbf{Mapping} \\
\begin{center}
\begin{tabular}{l l}
    $\A \llb x\rrb \sigma$ & $= \sigma(x)$ \\
    $\A \llb n\rrb \sigma$ & $= \mathcal{N}\llb n\rrb$ \\
    $\A \llb e_1 \, op \, e_2\rrb \sigma$ & $= \A\llb e_1\rrb \, \overline{op} \, \A\llb e_2\rrb$ 
\end{tabular}
\end{center}
with $\overline{op}$ the relation $\text{Val}\times\text{Val}$ corresponding to $op$

\subsection{Semantics of boolean expression}
\textbf{Semantic function}:
$$ \B: \text{Bexp}\li \text{State} \li \text{Val}$$
\textbf{Mapping} \\
\begin{center}
\begin{tabular}{l l}
    $\B \llb e_1 \, op \, e_2 \rrb \sigma$ & $=
    \begin{cases}
        \tt & \text{if } \A \llb e_1\rrb \sigma \, \overline{op} \, \A \llb e_2\rrb \sigma \\
        \ff & \text{otherwise}
    \end{cases}$ \\
    $\B \llb b_1 \ort b_2 \rrb \sigma$ & $=
    \begin{cases}
        \tt & \text{if } \B \llb b_1\rrb \sigma = \tt \text{ or } \B \llb b_2\rrb \sigma  = \tt\\
        \ff & \text{otherwise}
    \end{cases}$ \\
    $\B \llb b_1 \andt b_2 \rrb \sigma$ & $=
    \begin{cases}
        \tt & \text{if } \B \llb b_1\rrb \sigma  = \tt \text{ and } \B \llb b_2\rrb \sigma  = \tt\\
        \ff & \text{otherwise}
    \end{cases}$ \\
    $\B \llb \nott b \rrb \sigma$ & $=
    \begin{cases}
        \tt & \text{if } \B \llb b\rrb \sigma = \ff \\
        \ff & \text{otherwise}
    \end{cases}$ \\
\end{tabular}
\end{center}
with $\overline{op}$ the relation $\text{Val}\times\text{Val}$ corresponding to $op$

\subsection{Free variables}
\begin{center}
    \begin{tabular}{l l}
        $FV(e_1 \, op \, e_2)$ & $=FV(e_1) \cup FV(e_2)$ \\
        $FV(n)$ & $=\emptyset$ \\
        $FV(x)$ & $=\{x\}$ \\
        $FV(\nott b)$ & $=FV(b)$ \\
        $FV(b_1 \ort b_2)$ & $=FV(b_1) \cup FV(b_2)$ \\
        $FV(b_1 \andt b_2)$ & $=FV(b_1) \cup FV(b_2)$ \\
        $FV(\skipt)$ & $= \emptyset$ \\
        $FV(x:=e)$ & $= \{x\} \cup FV(e)$ \\
        $FV(s_1;s_2)$ & $= FV(s_1) \cup FV(e_2)$ \\
        $FV(\ift b \thent s_1 \elset s_2 \endt )$ & $= FV(b) \cup FV(s_1) \cup FV(s_2)$ \\
        $FV(\whilet b \dot s \endt)$ & $= FV(b) \cup FV(s)$ \\
    \end{tabular}
\end{center}

\subsection{Substitution}

\begin{center}
    \begin{tabular}{l l}
        $(e_1 \, op \, e_2)[x \mapsto e]$ & $\equiv (e_1[x\mapsto e])$ \\
        $n[x\mapsto e]$ & $\equiv n$\\
        $y[x\mapsto e]$ & $\equiv\begin{cases} e & \text{if } x \equiv y \\ y & \text{otherwise} \end{cases}$\\
        $(\nott b)[x\mapsto e]$ & $\nott (b[x\mapsto e])$ \\
        $(b_1 \ort b_2)[x\mapsto e]$ &  $(b_1[x\mapsto e] \ort b_2[x\mapsto e])$ \\
        $(b_1 \andt b_2)[x\mapsto e]$ &  $(b_1[x\mapsto e] \andt b_2[x\mapsto e])$ \\
    \end{tabular}
\end{center}

Substitution Lemma:
$$ \B \llb b [x \mapsto e]\rrb \sigma = \B \llb b\rrb (\sigma[x \mapsto \A \llb e \rrb \sigma])$$

\subsection{Structural induction on arithmetic and boolean expressions}
\subsubsection{Session sheet 10, Ex. 2}
Statement: $ \forall \sigma, e, e', x \, \A \llb e [x \mapsto e']\rrb \sigma = \A \llb e \rrb (\sigma[x \mapsto \A \llb e' \rrb \sigma])$
\begin{proof}
    Let $\sigma, x, e'$ be arbitrary. \\
    Let $P(e) \equiv (\A \llb e [x \mapsto e']\rrb \sigma = \A \llb e \rrb (\sigma[x \mapsto \A \llb e' \rrb \sigma]))$.\\
    We prove $\forall e. P(e)$ by strong structural induction on $e$. \\
    We want to show $P(e)$ for some arbitrary $e$ and assume $\forall e''  \sqsubset e \, P(e')$ \\
    \textbf{Case} $e \equiv n$ for some numerical value n:\\
    \dots \\
    \textbf{Case} $e \equiv y$ for some variable y:\\
    \dots \\
    \textbf{Case} $e \equiv e_1 \, op \, e_2$ for some arithmetic expressions $e_1, e_2$:\\
    \dots \\
\end{proof}

\subsubsection{Sheet 10, Ex. 2}
Statement: $ \forall \sigma, e, e', x \, (\B \llb b [x \mapsto e]\rrb \sigma = \B \llb b\rrb (\sigma[x \mapsto \A \llb e \rrb \sigma]))$
\begin{proof}
    Let $\sigma, x, e$ be arbitrary. \\
    Let $P(b) \equiv (\B \llb b [x \mapsto e]\rrb \sigma = \B \llb b\rrb (\sigma[x \mapsto \A \llb e \rrb \sigma]))$.\\
    We prove $\forall b. P(b)$ by strong structural induction on $e$. \\
    We want to show $P(e)$ for some arbitrary $b$ and assume $\forall b''  \sqsubset b \, P(b')$ \\
    \textbf{Case} $b \equiv b_1 \ort b_2$ for some boolean expressions $b_1,b_2$:\\
    \dots \\
    \textbf{Case} $b \equiv b_1 \andt b_2$ for some boolean expressions $b_1,b_2$:\\
    \dots \\
    \textbf{Case} $b \equiv \nott b'$ for some boolean expression $b'$:\\
    \dots \\
    \textbf{Case} $b \equiv e_1 \, op \, e_2$ for some arithmetic expressions $e_1, e_2$:\\
    \dots \\
\end{proof}


\end{document}
